# Mysql知识

## 一、索引

### 1. 为什么Mysql中索引要用b+树。

在`mysql`中，直接进行全表扫描查询非常慢，通常需要建立索引，这样可以大大提高查询效率。

##### B+树的特点

- 相较于b树，b+树的子节点必然是叶子节点，它的非叶子节点只存索引，这就使它能够在空间一定的情况下存更多的索引，有效减少磁盘io次数，提高了查询效率。同时，所有的查询最终都指向叶子节点，这也是mysql索引查询性能稳定的体现。

- b+树的所有叶子节点通过双向链表连接，范围查询十分方便。

   

##### 为什么不用二叉树

当使用二叉树时，如果id是连续递增的话，就需要从上自下遍历，效率很低

##### 为什么不用hash

hash的桶下标是通过两次hash和去mod运算生成的，通过桶下标查询元素的复杂度是O(1),但是它不适用于范围查询，因为它的存储没有连续关系

##### 为什么不用红黑树

红黑树是一种特殊的平衡二叉树。一个二叉查找树的子树必为红黑树。

缺点：当数据量很大时，索引的空间也会很大，导致内存可能存不下，

需要从磁盘上进行读取，树的层级越高，io的次数就越多，性能就会越差。

##### 为什么不用B树

b+树更好。

- 相较于b树，b+树的子节点必然是叶子节点，它的非叶子节点只存索引，这就使它能够在空间一定的情况下存更多的索引，有效减少磁盘io次数，提高了查询效率。同时，所有的查询最终都指向叶子节点，这也是mysql索引查询性能稳定的体现。
- b+树的所有叶子节点通过双向链表连接，范围查询十分方便。

### 2. sql慢查询的场景

- 没有建立索引。比如查询一个用户的订单记录，where后面跟着uerid、type、status等多个and连接的条件。此时适合通过建立三个字段的联合索引，提高查询效率。
- 没有命中索引。比如我们按时间倒序查询某个用户的订单列表。而我们以用户id和订单状态建立联合索引查询的话，后面的order by time没有命中索引，会走filesort，导致查询效率变低。索引排序一般是基于内存排序，所以我们需要建立合适的索引使索引命中。建立userid_time联合索引。

### 3.mysql优化的理解

- 硬件，查询速度主要和cpu有关，可以根据项目体量合理配置

- mysql配置，可以通过my.cnf配置最大连接数

- 慢sql定位，主要是通过slow_query_log查询慢sql日志，定位慢查询语句。通过开启show profiles,来具体分析查询的资源开销情况，比如内存开销、io开销、cpu开销。

  

### 4. 避免慢sql的方法

- 基于索引做sql查询
- 避免查询语句是使用函数和和运算符，会导致索引失效
- like的%尽量放在右侧，负责会导致索引失效
- 多条件查询做联合索引命中的索引越多越好
- 返回有用的列，避免select *
- 尽可能使用sql语句用到的索引完成排序，避免filesort