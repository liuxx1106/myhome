# 题集

## 一面

### 1. 常规自我介绍

### 2. 项目难点

### 3. redis的版本，高可用架构，优劣势，如何搭建，数据同步过程

6.0；

主从模式、哨兵模式、集群模式。

主从模式，一个master,多个slave. 全量复制，增量更新

哨兵模式，加入哨兵集群对节点进行监控，每秒向master和slave发送ping命令，若超过响应阈值，则主观上认为该节点宕机了。然后会等待其它setinal监测，若也是判断为宕机，则让该节点下线，若为主节点，则由其它setinal选举一个从节点为新的主节点，其它的从节点都指向它。

集群模式，去中心化思想。可以有多个主节点，数据分片存储，也就是说每个redis节点存储不同的数据，支持在线扩容。通过插槽算法将把整个数据库16384个槽，如果某个槽的node不能工作，那么它对应的槽失效，会导致集群无法工作。gossip协议，

优点：

- 无中心结构，部署简单。所有的Redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。- 
- 可扩展性，可扩展master节点，释放单个master的写数据压力，节点可动态添加或删除
- 能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换。
  



### 4. mysql场景题，银行卡，先查有1000，再加500，两个事务同时处理会是啥结果

主要与一下三方面有关。1. 隔离级别 2. 执行先后顺序 3. 提交顺序。

因为`mysql`默认的隔离级别是可重复读，以此为例。

如果加操作执行并提交了，这边的查询操作执行并提交，那么结果为1500。否则结果为1000。

读未提交的话，只要加操作先执行了。那么查到的就是1500。否则为1000

读已提交：加操作先执行并提交了，查询语句查到的为1500.

串行化：加操作先执行的话会获得写锁，阻塞查询事务。待加操作执行完并提交，才会释放锁，此时再去查询会得到1500.

### 5. 三次握手，四次挥手

>**TCP**：传输控制协议（transmission controller protocol）: 面向连接的，基于字节流的，可靠的传输层控制协议
>
>**SYN**：同步序列编号(synchronize sequence numbers)：tcp/ip建立连接时的握手信号。1表示建立连接
>
>**FIN**：TCP报头的码位字段（function item numbers）: 值为1时表示发送方字节流结束，用于关闭连接
>
>**ACK**: 确认字符(acknowledge character): 在数据传输过程中，接收方发给发送方的一种传输类控制字符，表示发来的数据已确认接受无误。
>
>**seq/ISN**: 初始化序列号（initial Sequence numbers）: 由客户端或者服务端创建的随机序列号。ISN不能设置为固定值，负责容易被攻击者猜到后续的确认号。

##### 客户端的三种状态

<span style="color:red">closed</span>: 默认关闭状态。<span style="color:red">SYN_sent</span>：请求连接状态<span style="color:red">ESTABLISHED</span>：连接成功状态

服务端的三种状态：<span style="color:red">listening</span>: 监听状态 <span style="color:red">SYN_rcvd</span>:等待请求确认<span style="color:red">ESTABLISHED</span>：连接成功状态

##### 三次握手

1. 客户端向服务端发生一段带有syn标志的数据包，并将自身状态改为`SYN_SENT`。

   > SYN = 1, seq = x;

2. 服务端接收到来自客户端的报文后，结束Listening监听状态，并返回一段SYN+ACK的数据包，表示确认已收到客户端数据，并将自身状态改为`SYN_RCVD`.

   > SYN = 1, ACK = 1, seq = y , ack = x + 1;

3. 客户端收到来自服务端的确认收到数据的报文后，在次发送一段报文，表明客户端已收到服务器端的确认信号，同时将自身状态改为`ESTABLISHED`(连接成功状态)，服务器端收到报文后，也将自身状态改为`ESTABLISHED`

   > SYN = 1, seq = x+1, ack = y+1

##### 四次挥手

1. 客户端向服务端发送一段带有FIN表示的数据包，请求断开连接，并停止发送数据，主动断开tcp连接，并将自身状态改为`FIN_wait1`，等待服务器确认

   > FIN = 1, seq = x;

2. 服务端收到来自客户端的请求报文，向客户端发送一段带有ACK标志的数据包，表示了可以断开，并将自身状态改为`closed_wait`,客户端收到此报文后，状态改为`FIN_wait2`

   > ACK = 1, seq = y, ack = x+1;

3. 服务端准备断开连接，向客户端发送一段带有FIN的数据包，此时状态改为`LAST_ACK`,等待服务端发送完所有数据后，再次向客户端发送FIN+ACK数据包，确认断开连接

   > FIN=1,ACK= 1, seq = z , ack = x+1

4. 客户端收到FIN+ACK报文，在次向服务端发送ACK报文回应，等待一段时间后，如果没有收到来自服务端的回应则直接进入`closed`状态。服务器在收到来自客户端的ACK报文后，直接`closed`,不做回应。

   > ACK = 1, seq = x+1, ack = z+1

### 6. seq是干嘛的

seq 初始序列号，

### 7. 四次挥手fin_wait介绍一下

### 8. 浏览器输入网址到界面渲染中间具体流程

1. url解析

   > 验证url的合法性，查看是否有该url缓存，如果有直接请求；否则进行dns解析

2. DNS解析

   > 将DNS数据解析为ip地址，如果已经是ip,则省略这一步

3. TCp连接

4. 客户端发送http请求

5. 服务端响应请求并返回数据

6. 断开连接

7. 页面渲染

   > - 解析html,搭建DOM树
   > - 解析css,并搭建样式树
   > - 将html和css结合，搭建render树
   > - 根据render树计算布局
   > - 将元素绘制到页面上

### 9. http和https?加密过程？https用的啥加密？对称还是非对称？

##### http：超文本传输协议：

- 容易被窃听
- 容易被篡改
- 容易被伪造身份

##### https：安全的传输协议

- 数据加密、
- 完整性摘要
- 数字证书

##### 加密过程：

>##### 对称加密：加密和解密使用同一把密钥
>
>分组加密：原理是将数据按照bit位分组位k个bit位的数据，每个分组通过一对一的映射表进行加密。此时K以及映射表就是对称算法中的密钥。
>
>常用的对称算法： `DES`、`3DES`、`AES`等
>
>##### 非对称加密：加密和解密的钥匙不同，分为公钥和私钥
>
>特点：公钥加密只有私钥可以解密；私钥加密，只有公钥可以解密。公钥对外公开，私钥只有自己知道
>
>常用的非对称加密算法：`RSA`、`EDHE`
>
>##### 混合加密：对称加密算法的弱点在于协商密钥的过程采用明文不安全，存在密钥泄漏的可能。https采用混合加密方式，**用非对称加密算法传输密钥，用对称加密算法传输实际数据。**此密钥一般称为`『会话密钥』`。

##### 摘要算法: 也叫哈希算法，其输入为任意数据，输出为固定长度的字符串（称为摘要）。

> 特点：
>
> - 不可逆，无法通过输出反推输入
> - 相同的输入一定得到相同的输出
> - 不同的输入大概率得到不同的输出
> - 无论输入的数据有多长，输出的摘要的长度固定不变
>
> ##### 完整性摘要
>
> 发送数据是，利用摘要算法将数据生成一个摘要，接收方拿到数据后，利用同样的摘要算法再次得到数据的摘要，并将其与发送方的摘要比对。
>
> 为了防止摘要被篡改，必须有一个接收方和发送方两者才知道的密钥，称之为鉴别密钥。
>
> 有了鉴别密钥，摘要算法的输入为数据和鉴别密钥。由于黑客不知道鉴别密钥，就无法篡改摘要。经过摘要算法生成报文鉴别吗，简称MAC。

##### 数字证书：用于解决http协议中身份容易被伪造的问题

> 一般需要向认证中心CA申请。

### 10. web应用有哪些安全问题？清楚多少说多少？

> ##### 10.1 SQL 注入
>
> SQL注入攻击的核心在于让Web服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。
>
> ##### 10.2 XSS攻击(跨站脚本攻击）
>
> XSS全称跨站脚本攻击（Cross Site Scripting），为了与重叠样式表CSS区分，换了另一个缩写XSS。
>
> ##### 10.3 CSRF攻击
>
> 跨站请求伪造。在A网站已经打开的情况下，另开tab页面打开恶意网站B，此时页面B恶意操作使浏览器请求A,由于之前之前A已经存有cookie信息，所以服务端无法判断A的请求是不是用户真实的意愿
>
> ##### 10.4 DDOS 攻击
>
> 攻击者使用多台计算机或者集群不断地发出访问请求，使服务阻塞，让合法的用户请求无法及时处理。
>
> ##### 10.5 数据劫持
>
> 对服务端返回的数据进行劫持，一般来说劫持的数据为敏感信息或有价值的数据。
>
> ##### 10.6 暴力破解
>
> 弱密码被熟人或者使用破解工具破解
>
> 解决方案：提高密码复杂度。
>
> ##### 10.7 信息泄露
>
> 由于web服务器没有正确的处理一些错误请求，导致返回了系统敏感信息，如tomcat版本等。
>
> 解决：应用程序报错时，不对外暴漏调试信息。
>
> ##### 10.8 文件上传脚本
>
> 如果对文件上传格式要求不严，比如上传了有恶意代码的shell脚本，可能对服务器造成危害。
>
> 解决：严格限制上传的文件类型以及限制上传相关目录的权限
>
> 
>
> 



### 11. linux下，某个程序端口如何查

netstat -antp|grep ""  lsof

### 12. 如果一个linux系统，用来存储生成日志，如果通过df发现磁盘没空间了，但是日志目录却没有太多的文件，如何排查？如何解决？

>1. 通过du -sh *去查看有没有对应的大文件
>2. 怀疑inode不够导致此问题，使用df -i
>3. 使用lsof检查，是否文件已经删除，但有进程还在存活。如果有则关闭对应进程
>4. 如果以上都无法解决，可卸载挂载点重新挂载。

### 13. 斐波那契数列。递归，dp,dp优化。

## 三面

### 1. 画一下你接触最深的项目的系统架构

### 2. 此架构图有哪些需要改进的点

### 3. kafka了解过吗？ 介绍下系统架构

### 4. 了解dubbo?介绍下dubbo和springcloud的区别

### 5. dubbo的分层？负载均衡如何实现?有哪几种？

### 6. Redis的持久化方式



### 四、node 

Node.js是一种基于V8 JavaScript引擎的运行时环境，用于构建高性能的网络应用程序。它的单线程事件循环模型和异步编程方式使得它在处理大量并发请求、实时应用和数据密集型应用方面非常出色。在后端开发中，Node.js也得到了广泛的应用，下面我们来详细说明一下Node.js做后端开发的优缺点。

优点：

1. 高性能：Node.js使用V8 JavaScript引擎，这使得它的性能非常高，能够处理大量并发请求。由于其单线程事件循环模型，它能够有效地处理I/O密集型操作。这使得Node.js非常适合实时应用、即时通讯等应用场景。
2. 简单易学：Node.js使用JavaScript作为开发语言，这是前端开发人员非常熟悉的语言，这使得他们可以快速转换到后端开发，减少学习成本。而且Node.js的API也非常简单易用，使得开发者能够快速地构建Web应用程序。
3. 生态系统丰富：Node.js拥有庞大的生态系统，有很多优秀的库和框架可以使用。例如，Express是一个轻量级的Web框架，Koa是一个更加灵活的框架，可以让开发者更加容易地构建Web应用程序。此外，Node.js还有很多其他的库和框架，如[http://Socket.io](https://link.zhihu.com/?target=http%3A//Socket.io)、Sequelize等，都能够大大提高开发效率。
4. 可复用性高：Node.js的模块化系统使得开发者可以轻松地组合和重用代码。这种模块化的思想使得开发者可以将代码分解成独立的组件，然后在不同的项目中复用这些组件，大大提高了代码的可维护性和可重用性。
5. 社区支持强大：Node.js有一个庞大的社区，开发者可以在社区中得到很多帮助和支持。社区中有很多开源项目、文档、教程等资源，可以让开发者更快地学习和掌握Node.js的技术。
6. 跨平台支持：Node.js可以在多个平台上运行，如Windows、Linux、Mac OS等。这使得开发者可以在不同的平台上开发和测试应用程序，提高了开发的灵活性和可移植性。

缺点：

1. 不适合CPU密集型操作：由于Node.js的单线程模型，如果代码中存在CPU密集型操作，会导致性能问题。这是因为单线程模型无法利用多核CPU的优势，因此在处理CPU密集型操作时，Node.js的性能可能不如其他多线程技术。
2. 回调函数过多：Node.js的异步编程方式使得代码中会出现很多回调函数，这会导致代码可读性变差和难以维护。解决这个问题的方法是使用Promise或async/await等技术，但是这也需要更多的学习和实践。
3. 安全性问题：由于Node.js是开源的，它的核心代码和第三方模块都是开放的。这也使得Node.js的安全性成为一个问题。开发者必须时刻注意安全问题，并使用一些安全措施来保护应用程序。
4. 内存泄漏问题：由于Node.js使用V8引擎，它的垃圾回收机制自动管理内存。但是如果开发者在代码中使用了一些不当的方式，会导致内存泄漏问题。这会导致应用程序的性能和稳定性下降。
5. 开发体验不如其他语言：由于Node.js是一门相对年轻的技术，它的开发工具和生态系统还不如其他语言，如Java、Python等。虽然Node.js有很多优秀的开发工具和框架，但是它们还没有达到其他语言的成熟程度。

总结：

Node.js作为一种高性能的后端开发技术，具有很多优点，如高性能、简单易学、生态系统丰富、可复用性高等。同时，它也存在一些缺点，如不适合CPU密集型操作、回调函数过多、安全性问题、内存泄漏问题等。在使用Node.js进行后端开发时，开发者需要认真权衡这些优缺点，选择适合自己项目的技术栈，并注意安全问题和性能优化。