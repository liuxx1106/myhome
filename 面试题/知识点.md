# 题集

## 一面

### 1. 常规自我介绍

### 2. 项目难点

### 3. redis的版本，高可用架构，优劣势，如何搭建，数据同步过程

6.0；

主从模式、哨兵模式、集群模式。

主从模式，一个master,多个slave. 全量复制，增量更新

哨兵模式，加入哨兵集群对节点进行监控，每秒向master和slave发送ping命令，若超过响应阈值，则主观上认为该节点宕机了。然后会等待其它setinal监测，若也是判断为宕机，则让该节点下线，若为主节点，则由其它setinal选举一个从节点为新的主节点，其它的从节点都指向它。

集群模式，去中心化思想。可以有多个主节点，数据分片存储，也就是说每个redis节点存储不同的数据，支持在线扩容。通过插槽算法将把整个数据库16384个槽，如果某个槽的node不能工作，那么它对应的槽失效，会导致集群无法工作。gossip协议，

优点：

- 无中心结构，部署简单。所有的Redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。- 
- 可扩展性，可扩展master节点，释放单个master的写数据压力，节点可动态添加或删除
- 能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换。
  



### 4. mysql场景题，银行卡，先查有1000，再加500，两个事务同时处理会是啥结果

主要与一下三方面有关。1. 隔离级别 2. 执行先后顺序 3. 提交顺序。

因为`mysql`默认的隔离级别是可重复读，以此为例。

如果加操作执行并提交了，这边的查询操作执行并提交，那么结果为1500。否则结果为1000。

读未提交的话，只要加操作先执行了。那么查到的就是1500。否则为1000

读已提交：加操作先执行并提交了，查询语句查到的为1500.

串行化：加操作先执行的话会获得写锁，阻塞查询事务。待加操作执行完并提交，才会释放锁，此时再去查询会得到1500.

### 5. 三次握手，四次挥手

tcp和udp区别

- TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务，UDP 是无连接的，即发送数据之前不需要建立连接，UDP 尽最大努力交付，即不保证可靠交付。
- UDP 具有较好的实时性，工作效率比 TCP 高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条 TCP 连接只能是一对一的，UDP 支持一对一，一对多，多对一和多对多的交互通信。
- UDP 分组首部开销小，TCP 首部开销 20 字节，UDP 的首部开销小，只有 8 个字节。
- TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流，UDP 是面向报文的一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位。
- UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP 等。

>**TCP**：传输控制协议（transmission controller protocol）: 面向连接的，基于字节流的，可靠的传输层控制协议
>
>**SYN**：同步序列编号(synchronize sequence numbers)：tcp/ip建立连接时的握手信号。1表示建立连接
>
>**FIN**：TCP报头的码位字段（function item numbers）: 值为1时表示发送方字节流结束，用于关闭连接
>
>**ACK**: 确认字符(acknowledge character): 在数据传输过程中，接收方发给发送方的一种传输类控制字符，表示发来的数据已确认接受无误。
>
>**seq/ISN**: 初始化序列号（initial Sequence numbers）: 由客户端或者服务端创建的随机序列号。ISN不能设置为固定值，负责容易被攻击者猜到后续的确认号。

##### 客户端的三种状态

<span style="color:red">closed</span>: 默认关闭状态。<span style="color:red">SYN_sent</span>：请求连接状态<span style="color:red">ESTABLISHED</span>：连接成功状态

服务端的三种状态：<span style="color:red">listening</span>: 监听状态 <span style="color:red">SYN_rcvd</span>:等待请求确认<span style="color:red">ESTABLISHED</span>：连接成功状态

##### 三次握手

1. 客户端向服务端发生一段带有syn标志的数据包，并将自身状态改为`SYN_SENT`。

   > SYN = 1, seq = x;

2. 服务端接收到来自客户端的报文后，结束Listening监听状态，并返回一段SYN+ACK的数据包，表示确认已收到客户端数据，并将自身状态改为`SYN_RCVD`.

   > SYN = 1, ACK = 1, seq = y , ack = x + 1;

3. 客户端收到来自服务端的确认收到数据的报文后，在次发送一段报文，表明客户端已收到服务器端的确认信号，同时将自身状态改为`ESTABLISHED`(连接成功状态)，服务器端收到报文后，也将自身状态改为`ESTABLISHED`

   > SYN = 1, seq = x+1, ack = y+1

##### 四次挥手

1. 客户端向服务端发送一段带有FIN表示的数据包，请求断开连接，并停止发送数据，主动断开tcp连接，并将自身状态改为`FIN_wait1`，等待服务器确认

   > FIN = 1, seq = x;

2. 服务端收到来自客户端的请求报文，向客户端发送一段带有ACK标志的数据包，表示了可以断开，并将自身状态改为`closed_wait`,客户端收到此报文后，状态改为`FIN_wait2`

   > ACK = 1, seq = y, ack = x+1;

3. 服务端准备断开连接，向客户端发送一段带有FIN的数据包，此时状态改为`LAST_ACK`,等待服务端发送完所有数据后，再次向客户端发送FIN+ACK数据包，确认断开连接

   > FIN=1,ACK= 1, seq = z , ack = x+1

4. 客户端收到FIN+ACK报文，在次向服务端发送ACK报文回应，等待一段时间后，如果没有收到来自服务端的回应则直接进入`closed`状态。服务器在收到来自客户端的ACK报文后，直接`closed`,不做回应。

   > ACK = 1, seq = x+1, ack = z+1

### 6. seq是干嘛的

seq 初始序列号，

### 7. 四次挥手fin_wait介绍一下

### 8. 浏览器输入网址到界面渲染中间具体流程

1. url解析

   > 验证url的合法性，查看是否有该url缓存，如果有直接请求；否则进行dns解析

2. DNS解析

   > 将DNS数据解析为ip地址，如果已经是ip,则省略这一步

3. TCp连接

4. 客户端发送http请求

5. 服务端响应请求并返回数据

6. 断开连接

7. 页面渲染

   > - 解析html,搭建DOM树
   > - 解析css,并搭建样式树
   > - 将html和css结合，搭建render树
   > - 根据render树计算布局
   > - 将元素绘制到页面上

### 9. http和https?加密过程？https用的啥加密？对称还是非对称？

##### http：超文本传输协议：

- 容易被窃听
- 容易被篡改
- 容易被伪造身份

##### https：安全的传输协议

- 数据加密、
- 完整性摘要
- 数字证书

##### 加密过程：

>##### 对称加密：加密和解密使用同一把密钥
>
>分组加密：原理是将数据按照bit位分组位k个bit位的数据，每个分组通过一对一的映射表进行加密。此时K以及映射表就是对称算法中的密钥。
>
>常用的对称算法： `DES`、`3DES`、`AES`等
>
>##### 非对称加密：加密和解密的钥匙不同，分为公钥和私钥
>
>特点：公钥加密只有私钥可以解密；私钥加密，只有公钥可以解密。公钥对外公开，私钥只有自己知道
>
>常用的非对称加密算法：`RSA`、`EDHE`
>
>##### 混合加密：对称加密算法的弱点在于协商密钥的过程采用明文不安全，存在密钥泄漏的可能。https采用混合加密方式，**用非对称加密算法传输密钥，用对称加密算法传输实际数据。**此密钥一般称为`『会话密钥』`。

##### 摘要算法: 也叫哈希算法，其输入为任意数据，输出为固定长度的字符串（称为摘要）。

> 特点：
>
> - 不可逆，无法通过输出反推输入
> - 相同的输入一定得到相同的输出
> - 不同的输入大概率得到不同的输出
> - 无论输入的数据有多长，输出的摘要的长度固定不变
>
> ##### 完整性摘要
>
> 发送数据是，利用摘要算法将数据生成一个摘要，接收方拿到数据后，利用同样的摘要算法再次得到数据的摘要，并将其与发送方的摘要比对。
>
> 为了防止摘要被篡改，必须有一个接收方和发送方两者才知道的密钥，称之为鉴别密钥。
>
> 有了鉴别密钥，摘要算法的输入为数据和鉴别密钥。由于黑客不知道鉴别密钥，就无法篡改摘要。经过摘要算法生成报文鉴别吗，简称MAC。

##### 数字证书：用于解决http协议中身份容易被伪造的问题

> 一般需要向认证中心CA申请。

### 10. web应用有哪些安全问题？清楚多少说多少？

> ##### 10.1 SQL 注入
>
> SQL注入攻击的核心在于让Web服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。
>
> ##### 10.2 XSS攻击(跨站脚本攻击）
>
> XSS全称跨站脚本攻击（Cross Site Scripting），为了与重叠样式表CSS区分，换了另一个缩写XSS。
>
> ##### 10.3 CSRF攻击
>
> 跨站请求伪造。在A网站已经打开的情况下，另开tab页面打开恶意网站B，此时页面B恶意操作使浏览器请求A,由于之前之前A已经存有cookie信息，所以服务端无法判断A的请求是不是用户真实的意愿
>
> ##### 10.4 DDOS 攻击
>
> 攻击者使用多台计算机或者集群不断地发出访问请求，使服务阻塞，让合法的用户请求无法及时处理。
>
> ##### 10.5 数据劫持
>
> 对服务端返回的数据进行劫持，一般来说劫持的数据为敏感信息或有价值的数据。
>
> ##### 10.6 暴力破解
>
> 弱密码被熟人或者使用破解工具破解
>
> 解决方案：提高密码复杂度。
>
> ##### 10.7 信息泄露
>
> 由于web服务器没有正确的处理一些错误请求，导致返回了系统敏感信息，如tomcat版本等。
>
> 解决：应用程序报错时，不对外暴漏调试信息。
>
> ##### 10.8 文件上传脚本
>
> 如果对文件上传格式要求不严，比如上传了有恶意代码的shell脚本，可能对服务器造成危害。
>
> 解决：严格限制上传的文件类型以及限制上传相关目录的权限
>
> 
>
> 



### 11. linux下，某个程序端口如何查

netstat -antp|grep ""  lsof

### 12. 如果一个linux系统，用来存储生成日志，如果通过df发现磁盘没空间了，但是日志目录却没有太多的文件，如何排查？如何解决？

>1. 通过du -sh *去查看有没有对应的大文件
>2. 怀疑inode不够导致此问题，使用df -i
>3. 使用lsof检查，是否文件已经删除，但有进程还在存活。如果有则关闭对应进程
>4. 如果以上都无法解决，可卸载挂载点重新挂载。

### 13. 斐波那契数列。递归，dp,dp优化。

#### 14. threadlocal

![1684075992864](D:\PF\myhome\面试题\assets\1684075992864.png)

## 三面

### 1. 画一下你接触最深的项目的系统架构

### 2. 此架构图有哪些需要改进的点

### 3. kafka了解过吗？ 介绍下系统架构

[Kafka系列-3-Kafka架构介绍 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/news/392786)

### 4. 了解dubbo?介绍下dubbo和springcloud的区别

springcloud: 

> springcloud是spring官方推出的一套微服务的解决方案，准确来说，springcloud是对项目中出现的各种微服务场景定义的一套标准规范。spring集成了netflix公司oss开源套件，eurka实现服务注册与发现，zuul实现应用网关、ribbon实现负载均衡、hystrix实现服务熔断。我们可以使用这套开源服务快速落地微服务应用。后面随着netflix这套组件的闭源与停止维护，spring官方也推出了一些组件，比如gateway做应用网关，loadblancer做负载均衡。同时阿里巴巴也推出了一系列组件，成为了另一套流行的微服务框架，比如dubbo实现rpc通信，nacos做服务的注册与发现与配置中心，setinal实现服务的限流与降级。

作用：1. 统一了规范

2. 降低了开发难度

dubbo: [(55条消息) Dubbo的原理与机制_dubbo原理和机制_又蠢又笨的懒羊羊程序猿的博客-CSDN博客](https://blog.csdn.net/TaylorSwiftiiln/article/details/120353520)

> Dubbo是一个RPC框架，RPC，即Remote Procedure Call（远程过程调用），相对的就是本地过程调用，在分布式架构之前的单体应用架构和垂直应用架构运用的都是本地过程调用。它允许程序调用另外一个地址空间（通常是网络共享的另外一台机器）的过程或函数，并且不用程序员显式编码这个远程调用的细节。
>
> 而分布式架构应用与应用之间的远程调用就需要RPC框架来做，目的就是为了让远程调用像本地调用一样简单。
> 

### 5. dubbo的分层？负载均衡如何实现?有哪几种？

[(55条消息) 简单认识dubbo中的几种负载均衡算法_dubbo怎么实现负载均衡_夜间沐水人的博客-CSDN博客](https://blog.csdn.net/qq_22610595/article/details/127816780)

### 6. Redis的持久化方式

>  bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。

> 对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

> 对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

### 四、node 

Node.js是一种基于V8 JavaScript引擎的运行时环境，用于构建高性能的网络应用程序。它的单线程事件循环模型和异步编程方式使得它在处理大量并发请求、实时应用和数据密集型应用方面非常出色。在后端开发中，Node.js也得到了广泛的应用，下面我们来详细说明一下Node.js做后端开发的优缺点。

优点：

1. 高性能：Node.js使用V8 JavaScript引擎，这使得它的性能非常高，能够处理大量并发请求。由于其单线程事件循环模型，它能够有效地处理I/O密集型操作。这使得Node.js非常适合实时应用、即时通讯等应用场景。
2. 简单易学：Node.js使用JavaScript作为开发语言，这是前端开发人员非常熟悉的语言，这使得他们可以快速转换到后端开发，减少学习成本。而且Node.js的API也非常简单易用，使得开发者能够快速地构建Web应用程序。
3. 生态系统丰富：Node.js拥有庞大的生态系统，有很多优秀的库和框架可以使用。例如，Express是一个轻量级的Web框架，Koa是一个更加灵活的框架，可以让开发者更加容易地构建Web应用程序。此外，Node.js还有很多其他的库和框架，如[http://Socket.io](https://link.zhihu.com/?target=http%3A//Socket.io)、Sequelize等，都能够大大提高开发效率。
4. 可复用性高：Node.js的模块化系统使得开发者可以轻松地组合和重用代码。这种模块化的思想使得开发者可以将代码分解成独立的组件，然后在不同的项目中复用这些组件，大大提高了代码的可维护性和可重用性。
5. 社区支持强大：Node.js有一个庞大的社区，开发者可以在社区中得到很多帮助和支持。社区中有很多开源项目、文档、教程等资源，可以让开发者更快地学习和掌握Node.js的技术。
6. 跨平台支持：Node.js可以在多个平台上运行，如Windows、Linux、Mac OS等。这使得开发者可以在不同的平台上开发和测试应用程序，提高了开发的灵活性和可移植性。

缺点：

1. 不适合CPU密集型操作：由于Node.js的单线程模型，如果代码中存在CPU密集型操作，会导致性能问题。这是因为单线程模型无法利用多核CPU的优势，因此在处理CPU密集型操作时，Node.js的性能可能不如其他多线程技术。
2. 回调函数过多：Node.js的异步编程方式使得代码中会出现很多回调函数，这会导致代码可读性变差和难以维护。解决这个问题的方法是使用Promise或async/await等技术，但是这也需要更多的学习和实践。
3. 安全性问题：由于Node.js是开源的，它的核心代码和第三方模块都是开放的。这也使得Node.js的安全性成为一个问题。开发者必须时刻注意安全问题，并使用一些安全措施来保护应用程序。
4. 内存泄漏问题：由于Node.js使用V8引擎，它的垃圾回收机制自动管理内存。但是如果开发者在代码中使用了一些不当的方式，会导致内存泄漏问题。这会导致应用程序的性能和稳定性下降。
5. 开发体验不如其他语言：由于Node.js是一门相对年轻的技术，它的开发工具和生态系统还不如其他语言，如Java、Python等。虽然Node.js有很多优秀的开发工具和框架，但是它们还没有达到其他语言的成熟程度。

总结：

Node.js作为一种高性能的后端开发技术，具有很多优点，如高性能、简单易学、生态系统丰富、可复用性高等。同时，它也存在一些缺点，如不适合CPU密集型操作、回调函数过多、安全性问题、内存泄漏问题等。在使用Node.js进行后端开发时，开发者需要认真权衡这些优缺点，选择适合自己项目的技术栈，并注意安全问题和性能优化。

